import pandas as pd
import numpy as np
from scipy.fftpack import fft,ifft
import matplotlib.pyplot as plt
import random
import scipy.stats as stats
from scipy import signal
from astropy.stats import median_absolute_deviation
from scipy.stats import iqr
from scipy.stats import entropy
from pylab import plot, log10, linspace, axis
from spectrum import *
df=pd.read_csv('Gyro_t.csv',header=None,sep=',')
L=len(df[1][1:])
sig=[]
for i in range(1,4):
    tem=[]
    for j in range(1,len(df[i])):
        tem.append(float(df[i][j]))
        #+random.gauss(mu,sigma)
    sig.append(tem)
x=np.linspace(0,1,len(df[1][1:]))
fig, (ax1, ax2,ax3,ax4,ax5) = plt.subplots(5, 1, sharex=True)
ax1.plot(x, sig[0])
ax1.set_title('sinusoids')
ax1.axis([0, 1, -1, 1])


####范数
def Euclidean_norm(x,y,z):
    return (x**2+y**2+z**2)**(1/3)
def CalMag(sigs):
    Mag=[]
    for i in range(len(sigs[0])):
        Mag.append(Euclidean_norm(sigs[0][i],sigs[1][i],sigs[2][i]))
    return Mag
Mag=CalMag(sig)
ax5.plot(x, Mag)
ax5.set_title('Magsignal')
ax5.axis([0, 1, -1, 1])


########Wn=2*截止频率/采样频率
#########中值滤波+三阶巴特沃斯滤波器20hz去噪
# def MidFilter():
mid = signal.medfilt(sig[0])
# sos =signal.butter(3, 0.4, 'lp', output='sos')
# filtered = signal.sosfilt(sos, mid,axis=0)
b, a = signal.butter(3, 0.4, 'lowpass')
filtered = signal.filtfilt(b, a, mid)#data为要过滤的信号
ax2.plot(x, filtered)
ax2.set_title('After 20 Hz low-pass filter')
ax2.axis([0, 1, -1, 1])
ax2.set_xlabel('Time [seconds]')


######三阶巴特沃斯滤波器 0.3hz分离重力加速度和身体加速度

#####tbodyacc##########
sos2 =signal.butter(3, 0.006, 'lp', analog=False, output='sos')
filtered1 = signal.sosfilt(sos2, filtered,axis=0)
ax3.plot(x, filtered1)
ax3.set_title('After 0.3 Hz low-pass filter')
ax3.axis([0, 1, -0.2, 0.2])
ax3.set_xlabel('Time [seconds]')


sos3=signal.butter(3, 0.006, 'hp', fs=100, output='sos')
filtered2 = signal.sosfilt(sos3, filtered)
ax4.plot(x, filtered2)
ax4.set_title('After 0.3 Hz high-pass filter')
ax4.axis([0, 1, -0.2, 0.2])
ax4.set_xlabel('Time [seconds]')
plt.tight_layout()
plt.show()

#######################
#####傅里叶##########
fs=2000
yy =fft(sig[0],fs)
yreal = yy.real               # 获取实数部分
yimag = yy.imag               # 获取虚数部分
yf=abs(yy)                # 取绝对值
yf1=abs(yy/len(x) )          #归一化处理
yf2 = yf1[:int(len(x)/2)]  #取一半区间

xf = np.arange(0,1.,1/fs)         # 频率
xf1 = xf
xf2 = xf[:int(len(x)/2)]  #取一半区间


plt.subplot(221)
plt.plot(x[0:500],sig[0][0:500])
plt.title('Original wave')

plt.subplot(222)
plt.plot(xf,yf,'r')
plt.title('FFT of Mixed wave(two sides frequency range)',fontsize=7,color='#7A378B')

plt.subplot(223)
plt.plot(xf1,yf1,'g')
plt.title('FFT of Mixed wave(normalization)',fontsize=9,color='r')

plt.subplot(224)
plt.plot(xf2,yf2,'b')
plt.title('FFT of Mixed wave)',fontsize=10,color='#F08080')


plt.show()
# print(dft_a)
# plt.plot(dft_a)
# plt.grid(True)
# plt.xlim(0, 15)
# plt.show()
#
# print(df)
# print(df.shape)
# print(df.info())




#mean（）：平均值
def Meansig(sigs):
    m=np.mean(sigs)
    return m
#std（）：标准偏差
def std(sigs):
    sig_std = np.std(sigs, ddof=1)
    return sig_std
#中位c查
def MAD(sigs):
    mads=median_absolute_deviation(sigs)
    return mads
# max（）：数组中的最大值
def sigMAX(sigs):
    return max(sigs)
# min（）：数组中的最小值
def sigMIN(sigs):
    return min(sigs)
# sma（）：信号幅度区域###3-dims
def sigSMA(sigs):
    all=0.
    for i in range(len(sigs[0])):
        all+=abs(sigs[0][i])+abs(sigs[1][i])+abs(sigs[2][i])
    all/=len(sigs[0])
    return all
# energy（）：能量度量平方和除以数量。####1 dim
#####归一化#######################################################################
#####
# %% 将数据归一化到[a,b]区间的方法
# a=0.1;
# b=0.5;
# Ymax=max(y);%计算最大值
# Ymin=min(y);%计算最小值
# k=(b-a)/(Ymax-Ymin);
# norY=a+k*(y-Ymin);
####################################################################################3
def norm(sigs):
    newsig=sigs
    Max=max(sigs)
    Min=min(sigs)
    a=-1
    b=1
    k=(b-a)/(Max-Min)
    for i in range(len(newsig)):
        newsig[i]=a+k*(newsig[i]-Min)
    return newsig
def energy(sigs):
    en=0.
    for i in sigs:
        en+=i**2
    en/=len(sigs)
    return en

# iqr（）：四分位数范围
def iqrs(sigs):
    return iqr(sigs)


# entropy（）：信号熵
def sigEntropy(sigs):
    return entropy(sigs,base=2)
# arCoeff（）：Burg阶等于4的自回归系数
def arCoeff(sigs):
    AR, P, k = arburg(sigs, 4)
    return AR[0].real,AR[1].real,AR[2].real,AR[3].real
# related（）：两个信号之间的相关系数
def corr(sigs):
    a,b,c=sigs[0],sigs[1],sigs[2]
    x1=np.corrcoef(a,b)[1][0]
    x2=np.corrcoef(a,c)[1][0]
    x3=np.corrcoef(b,c)[1][0]
    return x1,x2,x3

# maxInds（）：幅度最大的频率分量的索引###对FFT后
def maxinds(sigs):
    sig=sigs.tolist()
    idx,m= sig.index(max(sig)),max(sig)
    return (0.5-(idx/fs))*m
# meanFreq（）：获得平均频率的频率分量的加权平均值###FFT后

def meanFreq(sigs):
    sum=0.
    for i in sigs:
        sum+=i
    mean=sum/len(sigs)
    tot=0.
    for i in sigs:
        tot+=i*i/mean
    return tot/len(sigs)

# skewness（）：频域信号的偏斜度
#FFT
def skew(sigs):
    res=stats.skew(sigs, axis=0, bias=True)
    return abs(res)

# kurtosis（）：频域信号的峰度
def kur(sigs):
    res=stats.kurtosis(sigs)
    return res
# bandsEnergy（）：每个窗口的FFT的64个bin内的频率间隔的能量。
def bandEnergy(sig):  ####FFT
    inter = fs//8  #
    i = 0
    res = []
    while (i + 1) * inter <= 2000:
        x = 0
        j = 0
        for j in range(8):
            for i in range(inter):
                x += sig[j * inter + i] ** 2
            res.append(x / inter)

    return res###8个数

# angle（）：矢量之间的角度。
