import matplotlib.pyplot as plt
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.datasets.samples_generator import make_blobs
device=torch.device('cuda' if torch.cuda.is_available() else 'cpu')
#用sklearn的make_bolb生成数据集，特征值数取2，聚类取2
X,Y=make_blobs(n_samples=1000,n_features=2,centers=2,cluster_std=0.5,random_state=0)
# 标准化
X=(X-X.mean())/X.std()
Y[np.where(Y==0)]=-1
batch_size=32
# 硬分类
c=0.


sum_loss=0.

# 模型用nn.Linear().实现全连接
model=nn.Linear(2,1).to(device)
X=torch.FloatTensor(X)
Y=torch.FloatTensor(Y)
N=len(Y)

# 优化器用Adam收敛较好
optimizer=optim.Adam(model.parameters(),lr=0.1,betas=(0.99,0.999))

model.train()
epochs=50
for epoch in range(epochs):
    perm=torch.randperm(N)
    loss=0.
    for i in range(0,N,batch_size):
        x=X[perm[i:i+batch_size]].to(device)
        y=Y[perm[i:i+batch_size]].to(device)

        output=model(x).squeeze()
        weight=model.weight.squeeze()

        # hinge-loss
        loss=torch.mean(torch.clamp(1-y*output,min=0))
        loss+=c*(weight.t().dot(weight))/2.0

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        sum_loss+=loss.item()
    print("Epoch: {:4d}\tloss: {}".format(epoch, sum_loss / N))


# 复制的显示函数
def visualize(X, Y, model):
    W = model.weight.squeeze().detach().cpu().numpy()
    b = model.bias.squeeze().detach().cpu().numpy()

    delta = 0.001
    x = np.arange(X[:, 0].min(), X[:, 0].max(), delta)
    y = np.arange(X[:, 1].min(), X[:, 1].max(), delta)
    x, y = np.meshgrid(x, y)
    xy = list(map(np.ravel, [x, y]))

    z = (W.dot(xy) + b).reshape(x.shape)
    z[np.where(z > 1.0)] = 4
    z[np.where((z > 0.0) & (z <= 1.0))] = 3
    z[np.where((z > -1.0) & (z <= 0.0))] = 2
    z[np.where(z <= -1.0)] = 1

    plt.figure(figsize=(10, 10))
    plt.xlim([X[:, 0].min() + delta, X[:, 0].max() - delta])
    plt.ylim([X[:, 1].min() + delta, X[:, 1].max() - delta])
    plt.contourf(x, y, z, alpha=0.8, cmap="BuGn")
    plt.scatter(x=X[:, 0], y=X[:, 1], c="black", s=10)
    plt.tight_layout()
    plt.show()
visualize(X, Y, model)
